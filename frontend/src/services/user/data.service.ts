import { User } from '../../shared/models/user.model';
import { Friend } from '../../shared/models/friend.model';
import { dataApi } from '../../api/index.api';
import { AuthResponse } from '../../types/api.types';
import { currentService } from '../../services/index.service';
import { showAlert } from '../../utils/dom.utils';
import { isValidImage, checkImageExists } from '../../utils/image.utils';
import { UserStatus } from '../../shared/types/user.types';
import { DB_CONST, IMAGE_CONST } from '../../shared/config/constants.config'; // en rouge car dossier local 'shared' != dossier conteneur

// ============================================================================
// DATA SERVICE
// ============================================================================
/**
 * Service de gestion des utilisateurs et de la logique m√©tier.
 * 
 * Centralise toutes les op√©rations sur les utilisateurs.
 */
export class DataService {

	/**
	 * Met √† jour les propri√©t√©s de l'utilisateur avec de nouvelles donn√©es.
	 * 
	 * @param {number} id - Identifiant de l'utilisateur √† mettre √† jour
	 * @param {Record<string, string>} userData - Objet contenant les propri√©t√©s √† mettre √† jour
	 * @param {string} [alertDivId] - Identifiant de de la div o√π afficher l'alerte
	 * @returns {Promise<boolean>} - Promesse qui se resout lorsque l'utilisateur est mis √† jour
	 */
	public async updateUser(id: number, userData: Record<string, string>, alertDivId?: string): Promise<boolean> {
		const result: AuthResponse = await dataApi.updateUser(id, userData);
		if (result.errorMessage) {
			console.error(`[${this.constructor.name}] Erreur de mise √† jour utilisateur.`);
			showAlert(result.errorMessage, alertDivId);
			return false;
		}
		console.log(`[${this.constructor.name}] Utilisateur mis √† jour.`);
		showAlert('Infos successfully updated.', alertDivId, 'success');
		return true;
	}

	/**
	 * Met √† jour l'avatar de l'utilisateur courant.
	 * 
	 * Fait une requ√™te API pour mettre √† jour l'avatar de l'utilisateur courant.
	 * Si la requ√™te r√©ussit, affiche un message de succ√®s et return true.
	 * 
	 * @param {number} id - Identifiant de l'utilisateur courant.
	 * @param {File} file Le fichier image √† uploader.
	 * @returns {Promise<boolean>} - Promesse qui se resout lorsque l'avatar est mis √† jour.
	 */ 
	public async updateAvatar(id: number, file: File): Promise<boolean> {
		const validImage = isValidImage(file);
		if (!validImage) {
			return false;
		}
		const formData = new FormData();
		formData.append('avatar', file);
		const result: AuthResponse = await dataApi.updateAvatar(id, formData);
		if (result.errorMessage) {
			console.error(`[${this.constructor.name}] Erreur de mise √† jour de l'avatar utilisateur.`);
			showAlert(result.errorMessage);
			return false;
		}
		console.log(`[${this.constructor.name}] Avatar de l'utilisateur mis √† jour.`);
		showAlert('Image successfully uploaded.', 'alert-avatar', 'success');
		return true;
	}

	/**
	 * V√©rifie si un utilisateur est ami avec l'utilisateur courant.
	 * 
	 * R√©cup√®re la liste des amis de l'utilisateur courant et v√©rifie si l'utilisateur
	 * d'identifiant `userId` est pr√©sent dans cette liste. Si l'utilisateur est un ami,
	 * renvoie un objet contenant les informations de l'ami et le statut d'amiti√©.
	 * Sinon, renvoie `null`.
	 * 
	 * @param {number} userId - Identifiant de l'utilisateur √† v√©rifier.
	 * @returns {Promise<{ friend: Friend, status: string } | null>} - Promesse qui se r√©sout 
	 * avec un objet contenant l'ami et son statut ou `null` si l'utilisateur n'est pas ami.
	 */
	public async isFriendWithCurrentUser(userId: number): Promise<{ friend: Friend, status: string } | null> {
		const currentUserId = currentService.getCurrentUser()!.id;
		const userFriends: Friend[] = await dataApi.getUserFriends(currentUserId);
		if (!userFriends || userFriends.length === 0) {
			return null;
		}
		return userFriends.some(friend => friend.id === userId)
			? { friend: userFriends.find(friend => friend.id === userId)!,
				status: userFriends.find(friend => friend.id === userId)!.friendStatus }
			: null;
	}

	// ============================================================================
	// M√âTHODES UTILITAIRES
	// ============================================================================
	
	/**
	 * R√©cup√®re l'URL compl√®te de l'avatar d'un utilisateur.
	 *
	 * Si l'utilisateur n'a pas d'avatar d√©fini, ou que le fichier n'existe pas
	 * sur le serveur, retourne l'URL de l'avatar par d√©faut.
	 *
	 * @param {User} user - L'utilisateur pour lequel r√©cup√©rer l'avatar.
	 * @returns {Promise<string>} L'URL compl√®te de l'avatar de l'utilisateur.
	 */
	public async getUserAvatarURL(user: User): Promise<string> {
		const defaultUrl = `${IMAGE_CONST.ROUTE_API}${DB_CONST.USER.DEFAULT_AVATAR}`;
		if (!user.avatar) {
			return defaultUrl;
		}
		const avatarUrl = `${IMAGE_CONST.ROUTE_API}${user.avatar}`;
		const exists = await checkImageExists(avatarUrl);
		return exists ? avatarUrl : defaultUrl;
	}
	
	public async returnDefaultAvatarURL(): Promise<string> {
		return `${IMAGE_CONST.ROUTE_API}${DB_CONST.USER.DEFAULT_AVATAR}`;
	}

	/**
	 * Convertit un statut en libell√© lisible.
	 * 
	 * @returns Libell√© lisible
	 */
	public showStatusLabel(user: User): string {
		switch (user.status) {
			case 'online': return '<span class="text-green-500">üü¢ online </span>';
			case 'offline': return '<span class="text-red-500">üî¥ offline </span>';
			case 'in-game': return '<span class="text-yellow-500">üü° in game</span>';
			default: return 'Unknown';
		}
	}

	// ============================================================================
	// MANIPULATION DES COLLECTIONS D'UTILISATEURS
	// ============================================================================

	/**
	 * Filtre les utilisateurs actifs (non supprim√©s).
	 * 
	 * @param {User[]} users - Tableau d'instances User
	 * @returns {User[]} Tableau d'utilisateurs actifs
	 */
	public getActiveUsers(users: User[]): User[] {
		return users.filter(user => user.isActive);
	}

	/**
	 * Filtre les utilisateurs en ligne.
	 * 
	 * @param {User[]} users - Tableau d'instances User
	 * @returns {User[]} Tableau d'utilisateurs en ligne
	 */
	public getOnlineUsers(users: User[]): User[] {
		return users.filter(user => user.isOnline());
	}

	/**
	 * Filtre les utilisateurs par statut.
	 * 
	 * @param {User[]} users - Tableau d'instances User
	 * @param {UserStatus} status - Statut √† filtrer
	 * @returns {User[]} Tableau d'utilisateurs avec le statut sp√©cifi√©
	 */
	public getUsersByStatus(users: User[], status: UserStatus): User[] {
		return users.filter(user => user.status === status);
	}

	/**
	 * Recherche des utilisateurs par nom d'utilisateur.
	 * 
	 * @param {User[]} users - Tableau d'instances User
	 * @param {string} searchTerm - Terme de recherche
	 * @returns {User[]} Tableau d'utilisateurs correspondants
	 */
	public searchByUsername(users: User[], searchTerm: string): User[] {
		const term = searchTerm.toLowerCase();
		return users.filter(user => 
			user.username.toLowerCase().includes(term)
		);
	}

	/**
	 * Trie les utilisateurs par taux de victoire d√©croissant.
	 * 
	 * @param {User[]} users - Tableau d'instances User
	 * @returns {User[]} Tableau d'utilisateurs tri√©s
	 */
	public sortByWinRate(users: User[]): User[] {
		return [...users].sort((a, b) => b.winRate - a.winRate);
	}

	/**
	 * Trie les utilisateurs par nombre de parties jou√©es d√©croissant.
	 * 
	 * @param {User[]} users - Tableau d'instances User
	 * @returns {User[]} Tableau d'utilisateurs tri√©s
	 */
	public sortByGamesPlayed(users: User[]): User[] {
		return [...users].sort((a, b) => b.gamePlayed - a.gamePlayed);
	}
}